package interpreter.tree;

import java.util.LinkedList;
import java.util.List;

import renderable.RenderableBlock;
import codeblocks.Block;
import codeblocks.BlockConnector;

/**
 * This class is responsible for parsing a program given by the workspace.
 * @author Brandon Oubre
 */
public class Parser {
	/*
	 * Default results for missing arguments.
	 */
	private static final StringResult DEFAULT_STRING_RESULT = () -> "";
	private static final BooleanResult DEFAULT_BOOLEAN_RESULT = () -> false;
	private static final NumberResult DEFAULT_NUMBER_RESULT = () -> 0;
	
	/*
	 * Error Handling
	 */
	private List<ParseError> errors;
	private List<ParseError> warnings;
	
	/*
	 * The top-level blocks for each page.
	 */
	private Iterable<RenderableBlock> setupTopBlocks = null;
	//private Iterable<RenderableBlock> runtimeTopBlocks = null;
	
	/**
	 * Create a new parser.
	 * @param setupTopBlocks The top-level blocks from the setup page.
	 * @param runtimeTopBlocks The top-level blocks from the runtime page.
	 */
	public Parser(Iterable<RenderableBlock> setupTopBlocks, Iterable<RenderableBlock> runtimeTopBlocks) {
		this.setupTopBlocks = setupTopBlocks;
		//this.runtimeTopBlocks = runtimeTopBlocks;
		
		errors = new LinkedList<>();
		warnings = new LinkedList<>();
	}
	
	/**
	 * Raise a parse error.
	 * @param msg An appropriate error message.
	 */
	public void raiseError(Block b, String msg) {
		errors.add(new ParseError(b, msg));
	}
	
	/**
	 * Raise a parse warning.
	 * @param msg An appropriate warning message.
	 */
	public void raiseWarning(Block b, String msg) {
		warnings.add(new ParseError(b, msg));
	}
	
	/**
	 * @return The errors that arose during the parse.
	 */
	public List<ParseError> getErrors() {
		return errors;
	}
	
	/**
	 * @return The warnings that arose during the parse.
	 */
	public List<ParseError> getWarnings() {
		return warnings;
	}
	
	/**
	 * Retrieve the friendly name of a block
	 * @param b The block to query.
	 * @return The friendly name of the argument block.
	 */
	private static String getFriendlyName(Block b) {
		return b.getProperty("friendlyName");
	}
	
	/**
	 * Parse the given program.
	 * Errors and warnings will be raised to the console.
	 * @return <tt>null</tt> if the parse fails. Otherwise returns the {@link Program} (parse tree) generated by the parse.
	 */
	public Program parse() {
		//Clear errors and warnings.
		errors.clear();
		warnings.clear();
		
		//Do we have a program to parse?
		if (setupTopBlocks == null) {
			raiseError(null, "No program to parse.");
			return null;
		}
		
		//Find the setup block.
		Setup setup = null;
		for (RenderableBlock rb : setupTopBlocks) {
			Block b = rb.getBlock();
			if (b.getGenusName().equals("setup")) {
				if (setup == null) {
					setup = new Setup(b);
				} else {
					raiseError(b, "Duplicate setup blocks.");
					return null;
				}
			} else {
				raiseWarning(b, "Orphaned top-level blocks will not be executed.");
			}
		}
		
		if (setup == null) {
			raiseWarning(null, "No setup block. Assuming no setup routine.");
		} else {
			parse(setup);
		}	
		
		return new Program(setup);
	}
	
	/**
	 * Parse the setup procedure.
	 * @param setup The setup procedure.
	 */
	private void parse(Setup setup) {
		BlockConnector connector = setup.block.getSocketAt(0);
		while (connector.hasBlock()) {
			Block block = Block.getBlock(connector.getBlockID());
			setup.addCommand(parseCommand(block));
			connector = block.getAfterConnector();
		}
	}
	
	/**
	 * Parse a command block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private Command parseCommand(Block b) {
		switch (b.getGenusName()) {
		case "print":
			return new Print(b, parseStringArgument(b, 0));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
			return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a StringResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private StringResult parseStringResult(Block b) {
		switch (b.getGenusName()) {
		case "string":
			return new StringConstant(b);
		case "string-append":
			return new StringConcat(b, parseStringArgument(b, 0), parseStringArgument(b, 1));
		case "num-to-string":
			return new NumToString(b, parseNumericArgument(b, 0));
		case "bool-to-string":
			return new BoolToString(b, parseBooleanArgument(b, 0));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
			return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a NumberResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private NumberResult parseNumberResult(Block b) {
		switch (b.getGenusName()) {
		case "number":
			return new NumberConstant(b);
		case "pi":
			return new NumberConstant(b, Math.PI);
		case "e":
			return new NumberConstant(b, Math.E);
		case "sum":
			return new Sum(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "difference":
			return new Difference(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "product":
			return new Product(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "quotient":
			return new Quotient(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "power":
			return new Power(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
			return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a NumberResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private BooleanResult parseBooleanResult(Block b) { 
		switch (b.getGenusName()) {
		case "true": //Combined case intentional.
		case "false":
			return new BooleanConstant(b);
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
			return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a numeric argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private NumberResult parseNumericArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseNumberResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming 0 as value.");
			return DEFAULT_NUMBER_RESULT;
		}
	}
	
	/**
	 * Parse a string argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private StringResult parseStringArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseStringResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming empty string as value.");
			return DEFAULT_STRING_RESULT;
		}
	}
	
	/**
	 * Parse a boolean argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private BooleanResult parseBooleanArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseBooleanResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming false as value.");
			return DEFAULT_BOOLEAN_RESULT;
		}
	}
}
