package interpreter.tree;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import renderable.RenderableBlock;
import bayoubot.core.BayouBot;
import bayoubot.core.Pin;
import bayoubot.core.PinMode;
import bayoubot.core.PinState;
import codeblocks.Block;
import codeblocks.BlockConnector;
import codeblocks.BlockGenus;

/**
 * This class is responsible for parsing a program given by the workspace.
 * @author Brandon Oubre
 */
public class Parser {
	/*
	 * Default results for missing arguments.
	 */
	private static final StringResult DEFAULT_STRING_RESULT = () -> "";
	private static final BooleanResult DEFAULT_BOOLEAN_RESULT = () -> false;
	private static final NumberResult DEFAULT_NUMBER_RESULT = () -> 0;
	private static final PinResult DEFAULT_PIN_RESULT = () -> Pin.P1;
	
	/*
	 * Error Handling
	 */
	private List<ParseError> errors;
	private List<ParseError> warnings;
	
	/*
	 * The top-level blocks for each page.
	 */
	private Iterable<RenderableBlock> setupTopBlocks = null;
	private Iterable<RenderableBlock> mainLoopTopBlocks = null;
	private Iterable<RenderableBlock> procedureTopBlocks = null;
	
	/*
	 * Global variable look-up table.
	 */
	private Map<String, Result> lookupTable;
	
	/*
	 * Procedure look-up table.
	 */
	private Map<String, Procedure> procedures;
	private List<String> procedureNames;
	
	/*
	 * A reference to the bayou bot this program is controlling.
	 */
	private BayouBot bayouBot;
	
	/**
	 * Create a new parser.
	 * @param bayouBot The BayouBot this code will be controlling.
	 * @param setupTopBlocks The top-level blocks from the setup page.
	 * @param mainLoopTopBlocks The top-level blocks from the main loop page.
	 * @param procedureTopBlocks The top-level blocks from the procedures page.
	 */
	public Parser(BayouBot bayouBot, 
			Iterable<RenderableBlock> setupTopBlocks, 
			Iterable<RenderableBlock> mainLoopTopBlocks, 
			Iterable<RenderableBlock> procedureTopBlocks) {
		this.bayouBot = bayouBot;
		this.setupTopBlocks = setupTopBlocks;
		this.mainLoopTopBlocks = mainLoopTopBlocks;	
		this.procedureTopBlocks = procedureTopBlocks;
		
		errors = new LinkedList<>();
		warnings = new LinkedList<>();
		lookupTable = new HashMap<>();
		procedures = new HashMap<>();
		procedureNames = new ArrayList<>();
	}
	
	/**
	 * Raise a parse error.
	 * @param msg An appropriate error message.
	 */
	public void raiseError(Block b, String msg) {
		errors.add(new ParseError(b, msg));
	}
	
	/**
	 * Raise a parse warning.
	 * @param msg An appropriate warning message.
	 */
	public void raiseWarning(Block b, String msg) {
		warnings.add(new ParseError(b, msg));
	}
	
	/**
	 * @return The errors that arose during the parse.
	 */
	public List<ParseError> getErrors() {
		return errors;
	}
	
	/**
	 * @return The warnings that arose during the parse.
	 */
	public List<ParseError> getWarnings() {
		return warnings;
	}
	
	/**
	 * Retrieve the friendly name of a block
	 * @param b The block to query.
	 * @return The friendly name of the argument block.
	 */
	private static String getFriendlyName(Block b) {
		return b.getProperty("friendlyName");
	}
	
	/**
	 * Parse the given program.
	 * Errors and warnings will be raised to the console.
	 * @return <tt>null</tt> if the parse fails. Otherwise returns the {@link Program} (parse tree) generated by the parse.
	 */
	public Program parse() {
		//Clear errors and warnings.
		errors.clear();
		warnings.clear();
		//Clear tables and associations from the last parse.
		lookupTable.clear();
		procedures.clear();
		procedureNames.clear();
		
		//Do we have a program to parse?
		if (setupTopBlocks == null) {
			raiseError(null, "No program to parse.");
			return null;
		}
		
		//Find top-level unique blocks
		Block setupBlock = findUniqueProcedureBlock("setup", setupTopBlocks);
		Block mainLoopBlock = findUniqueProcedureBlock("mainLoop", mainLoopTopBlocks);
		if (setupBlock == null || mainLoopBlock == null) { //Either duplicate or missing block
			return null;
		}
		
		//Find and parse user-defined procedure blocks.
		List<Block> procBlocks = findProcedureBlocks(procedureTopBlocks);
		for (Block b : procBlocks) { //Load names first so we can check call validity later.
			String name = b.getBlockLabel();
			if (procedureNames.contains(name)) {
				raiseError(b, "Duplicate Procedure name. Please ensure all procedures are uniquely named.");
				return null;
			} else {
				procedureNames.add(name);
			}			
		}
		for (Block b : procBlocks) {
			procedures.put(b.getBlockLabel(), parseProcedure(b));
		}
		
		return new Program(parseProcedure(setupBlock), parseProcedure(mainLoopBlock), procedures);		
	}
	
	/**
	 * Find a unique top level procedure block of the given genus.
	 * @param genus The genus of block to find.
	 * @param topBlocks The top-level blocks of a given page.
	 * @return The unique block found. Will return <tt>null</tt> if no blocks are found or if duplicate blocks are found.
	 */
	private Block findUniqueProcedureBlock(String genus, Iterable<RenderableBlock> topBlocks) {
		Block uniqueBlock = null;
		for (RenderableBlock rb : topBlocks) {
			Block b = rb.getBlock();
			if (b.getGenusName().equals(genus)) {
				if (uniqueBlock == null) {
					uniqueBlock = b;
				} else {
					raiseError(b, "Duplicate " + BlockGenus.getGenusWithName(genus).getProperty("friendlyName") + " blocks.");
					return null;
				}
			} else {
				raiseWarning(b, "Orphaned top-level blocks will not be executed.");
			}
		}
		
		if (uniqueBlock == null) {
			raiseError(null, "No " + BlockGenus.getGenusWithName(genus).getProperty("friendlyName") + " block on appropriate page.");
		}
		
		return uniqueBlock;
	}
	
	/**
	 * Find all top-level procedure blocks.
	 * @param topBlocks The top-level blocks of a given page.
	 * @return A list of all top-level procedure blocks on the page.
	 */
	private List<Block> findProcedureBlocks(Iterable<RenderableBlock> topBlocks) {
		List<Block> procs = new ArrayList<>();
		for (RenderableBlock rb : topBlocks) {
			Block b = rb.getBlock();
			if (b.getGenusName().equals("procedure")) {
				procs.add(b);
			} else {
				raiseWarning(b, "Orphaned top-level blocks will not be executed.");
			}
		}
		
		return procs;
	}
	
	/**
	 * Parse a procedure block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private Procedure parseProcedure(Block b) {
		return new Procedure(b, b.getBlockLabel(), parseCommandList(b, 0));
	}
	
	/**
	 * Parse a command block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private Command parseCommand(Block b) {
		switch (b.getGenusName()) {
		case "print":
			return new Print(b, parseStringArgument(b, 0));
		case "if":
			return new If(b, parseBooleanArgument(b, 0), parseCommandList(b, 1), null);
		case "ifelse":
			return new If(b, parseBooleanArgument(b, 0), parseCommandList(b, 1), parseCommandList(b, 2));
		case "repeat":
			return new Repeat(b, parseNumericArgument(b, 0), parseCommandList(b, 1));
		case "while":
			return new RepeatWhile(b, parseBooleanArgument(b, 0), parseCommandList(b, 1));
		case "setvar-num":
			return new SetVariable<NumberResult>(b, lookupTable, parseStringArgument(b, 0), parseNumericArgument(b, 1));
		case "setvar-string":
			return new SetVariable<StringResult>(b, lookupTable, parseStringArgument(b, 0), parseStringArgument(b, 1));
		case "setvar-bool":
			return new SetVariable<BooleanResult>(b, lookupTable, parseStringArgument(b, 0), parseBooleanArgument(b, 1));
		case "setPinLow":
			return new SetPinState(b, bayouBot, parsePinArgument(b, 0), PinState.LOW);
		case "setPinHigh":
			return new SetPinState(b, bayouBot, parsePinArgument(b, 0), PinState.HIGH);
		case "setPinOutput":
			return new SetPinMode(b, bayouBot, parsePinArgument(b, 0), PinMode.OUTPUT);
		case "setPinInput":
			return new SetPinMode(b, bayouBot, parsePinArgument(b, 0), PinMode.INPUT);
		case "turnLeft":
			return new TurnLeft(b, bayouBot);
		case "turnRight":
			return new TurnRight(b, bayouBot);
		case "moveForward":
			return new MoveForward(b, bayouBot);
		case "moveBackward":
			return new MoveBackward(b, bayouBot);
		case "moveStop":
			return new MoveStop(b, bayouBot);
		case "sleep-ms":
			return new Sleep(b, parseNumericArgument(b, 0));
		case "call-proc":
			if (!procedureNames.contains(b.getBlockLabel())) {
				raiseError(b, "Attempt to call procedure that does not exist.");
			}
			return new CallProcedure(b, procedures);
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
		return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a StringResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private StringResult parseStringResult(Block b) {
		switch (b.getGenusName()) {
		case "string":
			return new StringConstant(b);
		case "var-string":
			return new StringVariable(b, lookupTable);
		case "string-append":
			return new StringConcat(b, parseStringArgument(b, 0), parseStringArgument(b, 1));
		case "num-to-string":
			return new NumToString(b, parseNumericArgument(b, 0));
		case "bool-to-string":
			return new BoolToString(b, parseBooleanArgument(b, 0));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
		return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a NumberResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private NumberResult parseNumberResult(Block b) {
		switch (b.getGenusName()) {
		case "number":
			return new NumberConstant(b);
		case "var-number":
			return new NumberVariable(b, lookupTable);
		case "pi":
			return new NumberConstant(b, Math.PI);
		case "e":
			return new NumberConstant(b, Math.E);
		case "sum":
			return new Sum(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "difference":
			return new Difference(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "product":
			return new Product(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "quotient":
			return new Quotient(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "power":
			return new Power(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "min":
			return new Min(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "max":
			return new Max(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "remainder":
			return new Remainder(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "random":
			return new RandomInt(b, parseNumericArgument(b, 0));
		case "round":
			return new Round(b, parseNumericArgument(b, 0));
		case "int":
			return new Int(b, parseNumericArgument(b, 0));
		case "abs":
			return new AbsoluteValue(b, parseNumericArgument(b, 0));
		case "sqrt":
			return new SquareRoot(b, parseNumericArgument(b, 0));
		case "sin":
			return new Sine(b, parseNumericArgument(b, 0));
		case "cos":
			return new Cosine(b, parseNumericArgument(b, 0));
		case "tan":
			return new Tangent(b, parseNumericArgument(b, 0));
		case "asin":
			return new ArcSine(b, parseNumericArgument(b, 0));
		case "acos":
			return new ArcCosine(b, parseNumericArgument(b, 0));
		case "atan":
			return new ArcTangent(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "log":
			return new Logarithm(b, parseNumericArgument(b, 0));
		case "ln":
			return new NaturalLogarithm(b, parseNumericArgument(b, 0));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
		return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a NumberResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private BooleanResult parseBooleanResult(Block b) { 
		switch (b.getGenusName()) {
		case "true": //Combined case intentional.
		case "false":
			return new BooleanConstant(b);
		case "var-bool":
			return new BooleanVariable(b, lookupTable);
		case "and":
			return new LogicAnd(b, parseBooleanArgument(b, 0), parseBooleanArgument(b, 1));
		case "or":
			return new LogicOr(b, parseBooleanArgument(b, 0), parseBooleanArgument(b, 1));
		case "not":
			return new LogicNot(b, parseBooleanArgument(b, 0));
		case "num-equals":
			return new NumericEquals(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "num-not-equals":
			return new NumericNotEquals(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "bool-equals":
			return new BooleanEquals(b, parseBooleanArgument(b, 0), parseBooleanArgument(b, 1));
		case "bool-not-equals":
			return new BooleanNotEquals(b, parseBooleanArgument(b, 0), parseBooleanArgument(b, 1));
		case "string-equals":
			return new StringEquals(b, parseStringArgument(b, 0), parseStringArgument(b, 1));
		case "string-not-equals":
			return new StringNotEquals(b, parseStringArgument(b, 0), parseStringArgument(b, 1));
		case "lessthan":
			return new LessThan(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "greaterthan":
			return new GreaterThan(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "lessthanorequalto":
			return new LessThanOrEqual(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "greaterthanorequalto":
			return new GreaterThanOrEqual(b, parseNumericArgument(b, 0), parseNumericArgument(b, 1));
		case "isHigh":
			return new IsPinHigh(b, bayouBot, parsePinArgument(b, 0));
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
		return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a PinResult block.
	 * @param b The block to parse.
	 * @return The resulting parse tree node.
	 */
	private PinResult parsePinResult(Block b) { 
		switch (b.getGenusName()) {
		case "pin1" :
			return new PinConstant(b, Pin.P1);
		case "pin2" :
			return new PinConstant(b, Pin.P2);
		case "pin3" :
			return new PinConstant(b, Pin.P3);
		case "pin4" :
			return new PinConstant(b, Pin.P4);
		case "pin5" :
			return new PinConstant(b, Pin.P5);
		case "pin6" :
			return new PinConstant(b, Pin.P6);
		case "pin7" :
			return new PinConstant(b, Pin.P7);
		case "pin8" :
			return new PinConstant(b, Pin.P8);
		case "pin9" :
			return new PinConstant(b, Pin.P9);
		case "pin10" :
			return new PinConstant(b, Pin.P10);
		case "pin11" :
			return new PinConstant(b, Pin.P11);
		case "pin12" :
			return new PinConstant(b, Pin.P12);
		default:
			assert false : "Unrecognized block genus. (Should not occur.)";
		return null; //Code should not be reached.
		}
	}
	
	/**
	 * Parse a list of chained commands.
	 * @param head The parent block of the command chain.
	 * @param socketNum Which socket the command chain is located at.
	 * @return A list of the commands attached to the specified socket.
	 */
	private List<Command> parseCommandList(Block head, int socketNum) {
		assert socketNum >= 0 && socketNum <= head.getNumSockets(): "Invalid socket number: " + socketNum;
		List<Command> commands = new ArrayList<>();
		BlockConnector connector = head.getSocketAt(socketNum);
		
		if (connector.hasBlock()) {
			while (connector.hasBlock()) {
				Block block = Block.getBlock(connector.getBlockID());
				commands.add(parseCommand(block));
				connector = block.getAfterConnector();
			}
		} else {
			raiseWarning(head, getFriendlyName(head) + " is missing commands. Assuming no commands attached.");
		}	
		
		return commands;
	}
	
	/**
	 * Parse a numeric argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private NumberResult parseNumericArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseNumberResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming 0 as value.");
			return DEFAULT_NUMBER_RESULT;
		}
	}
	
	/**
	 * Parse a string argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private StringResult parseStringArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseStringResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming empty string as value.");
			return DEFAULT_STRING_RESULT;
		}
	}
	
	/**
	 * Parse a boolean argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private BooleanResult parseBooleanArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parseBooleanResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming false as value.");
			return DEFAULT_BOOLEAN_RESULT;
		}
	}
	
	/**
	 * Parse a pin argument.
	 * @param b The original block.
	 * @param socketNum Which argument to parse.
	 * @return The parsed argument.
	 */
	private PinResult parsePinArgument(Block b, int socketNum) {
		assert socketNum >= 0 && socketNum <= b.getNumSockets(): "Invalid socket number: " + socketNum;
		BlockConnector socket = b.getSocketAt(socketNum);
		if (socket.hasBlock()) {
			return parsePinResult(Block.getBlock(socket.getBlockID()));
		} else {
			raiseWarning(b, getFriendlyName(b) + " block missing argument. Assuming Pin 1 as value.");
			return DEFAULT_PIN_RESULT;
		}
	}
}
